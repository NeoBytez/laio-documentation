"use strict";(self.webpackChunklaio_documentation=self.webpackChunklaio_documentation||[]).push([[373],{1407:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>c});var s=a(4848),i=a(8453);const t={title:"GPU Instancing",hide_table_of_contents:!1},r=void 0,o={id:"Samples/GPUInstancing",title:"GPU Instancing",description:"Overview",source:"@site/docs/Samples/GPUInstancing.md",sourceDirName:"Samples",slug:"/Samples/GPUInstancing",permalink:"/laio-documentation/Samples/GPUInstancing",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"GPU Instancing",hide_table_of_contents:!1},sidebar:"tutorialSidebar",previous:{title:"Bullet Solver",permalink:"/laio-documentation/Samples/BulletSolver"}},l={},c=[{value:"Overview",id:"overview",level:2},{value:"Base Classes",id:"base-classes",level:2},{value:"Classes",id:"classes",level:2},{value:"Class Summaries",id:"class-summaries",level:2},{value:"SingleInstanceManager",id:"singleinstancemanager",level:3},{value:"PoolInstanceManager",id:"poolinstancemanager",level:3},{value:"DynamicInstanceManager",id:"dynamicinstancemanager",level:3},{value:"MultiInstanceManager",id:"multiinstancemanager",level:3},{value:"LODInstanceManager",id:"lodinstancemanager",level:3},{value:"Mesh Set",id:"mesh-set",level:2},{value:"Order of execution",id:"order-of-execution",level:2},{value:"Performance",id:"performance",level:2},{value:"Instance Manager Base",id:"instance-manager-base",level:2},{value:"Public methods",id:"public-methods",level:3},{value:"Protected methods",id:"protected-methods",level:3},{value:"Single Instance Manager",id:"single-instance-manager",level:2},{value:"Pool Instance Manager",id:"pool-instance-manager",level:2},{value:"PoolInstanceData",id:"poolinstancedata",level:3},{value:"Public methods",id:"public-methods-1",level:3},{value:"Dynamic Instance Manager",id:"dynamic-instance-manager",level:2},{value:"Public Methods",id:"public-methods-2",level:3},{value:"Multi Instance Manager",id:"multi-instance-manager",level:2},{value:"LOD Instance Manager",id:"lod-instance-manager",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"Requires Unity.Jobs and Unity.Burst"})}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"What is GPU Instancing?"}),(0,s.jsx)(n.p,{children:"GPU instancing is a draw call optimization method that renders multiple copies of a mesh with the same material in a single draw call. Each copy of the mesh is called an instance. This is useful for drawing things that appear multiple times in a scene, for example, trees or bushes."}),(0,s.jsx)(n.p,{children:"GPU instancing renders identical meshes in the same draw call. To add variation and reduce the appearance of repetition, each instance can have different properties, such as Color or Scale. Draw calls that render multiple instances appear in the Frame Debugger as Render Mesh (instanced)."}),(0,s.jsxs)(n.p,{children:["Read more: ",(0,s.jsx)(n.a,{href:"https://docs.unity3d.com/Manual/GPUInstancing.html",children:"https://docs.unity3d.com/Manual/GPUInstancing.html"})]})]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"What is the Job System?"}),(0,s.jsx)(n.p,{children:"Unity\u2019s job system lets you create multithreaded code so that your application can use all available CPU cores to execute your code. This provides improved performance because your application uses the capacity of all the CPU cores it\u2019s running on more efficiently, rather than running all code on one CPU core."}),(0,s.jsx)(n.p,{children:"You can use the job system by itself, but for improved performance, you should also use the Burst compiler, which is specifically designed to compile jobs for Unity\u2019s job system. The Burst compiler has improved code generation, which results in increased performance and a reduction of battery consumption on mobile devices."}),(0,s.jsxs)(n.p,{children:["Read more: ",(0,s.jsx)(n.a,{href:"https://docs.unity3d.com/Manual/JobSystemOverview.html",children:"https://docs.unity3d.com/Manual/JobSystemOverview.html"})]})]}),"\n",(0,s.jsx)(n.p,{children:"By combining GPU instancing with Unity\u2019s Job System and Burst Compiler, you can render large numbers of meshes with exceptional performance. This is done through UnityEngine.Graphics, specifically using:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:"lineWrap=true",children:"Graphics.RenderMeshIsntanced<T>(RenderParams rparams, Mesh mesh, int subMeshIndex, NativeArray<T> instanceData, [int instanceCount = -1], [int startInstance = 0])`\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"NativeArray<T>"})," type will typically be Matrix4x4, which can be easily manipulated and is the optimal type to use within the Job System."]}),"\n",(0,s.jsx)(n.h2,{id:"base-classes",children:"Base Classes"}),"\n",(0,s.jsx)(n.p,{children:"Provides base classes to work off of, including:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Pool Instance Manager"}),"\n",(0,s.jsx)(n.li,{children:"Dynamic Instance Manager"}),"\n",(0,s.jsx)(n.li,{children:"Multi Instance Manager"}),"\n",(0,s.jsx)(n.li,{children:"LOD Instance Manager"}),"\n",(0,s.jsx)(n.li,{children:"Single Instance Manager"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Each scenario often requires a unique approach, which is why multiple classes are available to suit different needs. Writing your own manager class ensures no unnecessary computations impact performance."}),"\n",(0,s.jsx)(n.h2,{id:"classes",children:"Classes"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"alt image",src:a(3378).A+"",width:"2560",height:"1440"})}),"\n",(0,s.jsxs)(n.p,{children:["Green indicates base classes, while blue represents demos that utilize these base classes. All managers require a ",(0,s.jsx)(n.code,{children:"Matrix4x4"})," array, which contains the position, rotation, and scale information. These managers allow you to set positions, rotations, and scales, though adjustments are not always easily supported."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, the SingleInstanceManager does not utilize prerender jobs, making it purely boilerplate code that simply renders a ",(0,s.jsx)(n.code,{children:"NativeArray<Matrix4x4>"}),". This is ideal for cases like the Perlin Noise demo, where matrices are directly modified during prerender rather than storing additional NativeArrays. In contrast, the ",(0,s.jsx)(n.code,{children:"PoolInstanceManager"})," supports ",(0,s.jsx)(n.code,{children:"NativeArrays"})," for positions, rotations, and scales, allowing easy adjustments outside the Job System."]}),"\n",(0,s.jsx)(n.h2,{id:"class-summaries",children:"Class Summaries"}),"\n",(0,s.jsx)(n.h3,{id:"singleinstancemanager",children:"SingleInstanceManager"}),"\n",(0,s.jsx)(n.p,{children:"Minimal boilerplate for rendering a single mesh."}),"\n",(0,s.jsx)(n.h3,{id:"poolinstancemanager",children:"PoolInstanceManager"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Manages position, rotation, scale."}),"\n",(0,s.jsx)(n.li,{children:"Supports adding/removing points."}),"\n",(0,s.jsx)(n.li,{children:"Works with a single mesh."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"dynamicinstancemanager",children:"DynamicInstanceManager"}),"\n",(0,s.jsx)(n.p,{children:"Similar to PoolInstanceManager, but optimized for dynamic updates."}),"\n",(0,s.jsx)(n.h3,{id:"multiinstancemanager",children:"MultiInstanceManager"}),"\n",(0,s.jsx)(n.p,{children:"Handles multiple meshes with position, rotation, and scale data."}),"\n",(0,s.jsx)(n.h3,{id:"lodinstancemanager",children:"LODInstanceManager"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Uses ",(0,s.jsx)(n.code,{children:"MultiInstanceManager"})," as base"]}),"\n",(0,s.jsx)(n.li,{children:"Adds distance-based mesh selection for LOD."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"mesh-set",children:"Mesh Set"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"InstanceMeshSet"})," is a ",(0,s.jsx)(n.code,{children:"ScriptableObject"})," used by the instance managers. It contains an array of ",(0,s.jsx)(n.code,{children:"InstanceMesh"}),", where you can specify the mesh, material, and rendering options. You can create a new instance mesh set by right-clicking in the project window and selecting ",(0,s.jsx)(n.code,{children:"Laio/Instance Mesh Set"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public class InstanceMesh\r\n{\r\n    public Mesh mesh;\r\n    public Material material;\r\n    public int submeshIndex = 1;\r\n    public int layer;\r\n    public ShadowCastingMode shadowCastingMode;\r\n    public bool receiveShadows;\r\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["For single mesh managers, the mesh at index ",(0,s.jsx)(n.code,{children:"0"})," will be used."]}),"\n",(0,s.jsx)(n.h2,{id:"order-of-execution",children:"Order of execution"}),"\n",(0,s.jsxs)(n.p,{children:["The process starts with ",(0,s.jsx)(n.code,{children:"Setup()"}),", which sets up the camera and calls Allocation(). Note that ",(0,s.jsx)(n.code,{children:"InstanceManagerBase.cs"})," does not automatically call ",(0,s.jsx)(n.code,{children:"Allocate()"})," in ",(0,s.jsx)(n.code,{children:"Setup()"})," it is the responsibility of derived classes to do so."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Allocatate(bool)"})," handles the allocation of the ",(0,s.jsx)(n.code,{children:"NativeArray"}),"s needed by the manager. Cleanup is handled in Unity's ",(0,s.jsx)(n.code,{children:"OnDestroy()"})," method, invoking ",(0,s.jsx)(n.code,{children:"Deallocate()"}),". If you override ",(0,s.jsx)(n.code,{children:"Allocate()"})," and plan to allocate more ",(0,s.jsx)(n.code,{children:"NativeArray"}),"s, pass false when calling ",(0,s.jsx)(n.code,{children:"base.Allocate()"})," to prevent ",(0,s.jsx)(n.code,{children:"FinishAllocation()"})," from being invoked prematurely. Be sure to add the call at the end of your override."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"if (finishAllocation)\r\n    FinishAllocation();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["After allocation, ",(0,s.jsx)(n.code,{children:"PostAllocation()"})," is called to initialize any necessary data."]}),"\n",(0,s.jsxs)(n.p,{children:["During the update loop, ",(0,s.jsx)(n.code,{children:"PreRender()"})," is called to update data as needed, followed by ",(0,s.jsx)(n.code,{children:"Render()"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If you override ",(0,s.jsx)(n.code,{children:"PreRender()"}),", ensure that ",(0,s.jsx)(n.code,{children:"base.PreRender(false)"})," is passed false. Check if finishPreRender should be true. If so, call ",(0,s.jsx)(n.code,{children:"FinishPreRender()"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"protected override void PreRender(bool finishPreRender = true)\r\n{\r\n    base.PreRender(false);\r\n\r\n    //Code here\r\n\r\n    if (finishPreRender)\r\n        FinishPreRender();\r\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"performance",children:"Performance"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"InstanceManagerBase.cs"})," includes performance tracking constants. If you don\u2019t need this functionality, they can be removed along with the ",(0,s.jsx)(n.code,{children:"OnGUI()"})," method."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"it is all wrapped inside a UNITY_EDITOR, so it will not show up in builds"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"//Constants\r\npublic const KeyCode DISPLAY_PERFORMANCE_HOTKEY = KeyCode.Equals;\r\npublic const bool DEFAULT_PERFORMANCE_ON = true;\n"})}),"\n",(0,s.jsx)(n.h2,{id:"instance-manager-base",children:"Instance Manager Base"}),"\n",(0,s.jsx)(n.p,{children:"Overridable methods in the base class include:"}),"\n",(0,s.jsx)(n.h3,{id:"public-methods",children:"Public methods"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public virtual void Setup(int instances, Camera cam)\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public virtual void Setup(int instances)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"protected-methods",children:"Protected methods"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"protected virtual void Allocate(bool finishAllocation = true)\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"protected virtual void PostAllocation()\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"protected virtual void Deallocate()\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"protected virtual void PreRender(bool finishPreRender= true)\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"protected virtual void Render()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"single-instance-manager",children:"Single Instance Manager"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"SingleInstanceManager"})," is a lightweight implementation for rendering a single mesh. It uses a ",(0,s.jsx)(n.code,{children:"NativeArray<Matrix4x4>"})," to manage instance data. To start, override ",(0,s.jsx)(n.code,{children:"PostAllocation()"})," and initialize the ",(0,s.jsx)(n.code,{children:"_matrixData"})," array:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"protected override void PostAllocation()\r\n{\r\n    base.PostAllocation();\r\n    GridLayout();\r\n}\r\n\r\nprivate void GridLayout()\r\n{\r\n    int rowSize = (int)Mathf.Sqrt(AvailableInstances);\r\n\r\n    for (int i = 0; i < AvailableInstances; i++)\r\n    {\r\n        int x = i % rowSize;\r\n        int y = i / rowSize;\r\n\r\n        _matrixData[i] = Matrix4x4.TRS(\r\n            new float3(x, 0, -y),\r\n            Quaternion.identity,\r\n            Vector3.one);\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"pool-instance-manager",children:"Pool Instance Manager"}),"\n",(0,s.jsx)(n.h3,{id:"poolinstancedata",children:"PoolInstanceData"}),"\n",(0,s.jsxs)(n.p,{children:["The struct ",(0,s.jsx)(n.code,{children:"PoolInstanceData"})," is used to couple data related to a single instance together. Contains position, rotation, scale, along with the index in the ",(0,s.jsx)(n.code,{children:"NativeArray"})," and whether it should be rendered. The ",(0,s.jsx)(n.code,{children:"doRender"})," flag acts as whether it exists yet, if you try and add a point, it will go through the array of ",(0,s.jsx)(n.code,{children:"PoolInstanceData"})," and find the first instance where ",(0,s.jsx)(n.code,{children:"doRender = false"})," and override it."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public struct PoolInstanceData\r\n{\r\n    public Vector3 position;\r\n    public Quaternion rotation;\r\n    public Vector3 scale;\r\n\r\n    public int index;\r\n    public bool doRender;\r\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The PoolInstanceManager has 4 jobs. ",(0,s.jsx)(n.code,{children:"UpdateMatrixJob"}),", ",(0,s.jsx)(n.code,{children:"UpdatePointsJob"}),", ",(0,s.jsx)(n.code,{children:"AddPointsJob"}),", ",(0,s.jsx)(n.code,{children:"RemovePointsJob"}),". Whenever you call ",(0,s.jsx)(n.code,{children:"UpdatePointsJob"}),", ",(0,s.jsx)(n.code,{children:"AddPointsJob"})," or ",(0,s.jsx)(n.code,{children:"RemovePointsJob"})," the job will be executed immediately, therefore it is best to make all of the changes in batches rather then calling it many times. These changes get stored inside the ",(0,s.jsx)(n.code,{children:"NativeArray<PoolInstanceData>"})," and the flag ",(0,s.jsx)(n.code,{children:"doPreRender"})," is flagged, as changes have been detected. Prerender takes care of the ",(0,s.jsx)(n.code,{children:"UpdateMatrixJob"})," when it will go through the ",(0,s.jsx)(n.code,{children:"NativeArray<PoolInstanceData>"})," and populate the matrix data to be passed into render. The entire array will not always be used, therefore it also needs to track the length of useable data in the matrix array, which is the purpose of ",(0,s.jsx)(n.code,{children:"NativeArray<int> _matrixLength"}),". It is a ",(0,s.jsx)(n.code,{children:"NativeArray"})," to be passed to the jobs system with only the length of one."]}),"\n",(0,s.jsx)(n.h3,{id:"public-methods-1",children:"Public methods"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public void CopyData(out NativeArray<PoolInstanceData> data)\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public void UpdatePoints(NativeArray<PoolInstanceData> toUpdate)\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public void UpdatePoints(PoolInstanceData[] toUpdate)\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public void RemovePoints(int[] toRmove)\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public void AddPoints(PoolInstanceData[] toAdd)\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public void UpdateData(ref NativeArray<PoolInstanceData> data)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"dynamic-instance-manager",children:"Dynamic Instance Manager"}),"\n",(0,s.jsxs)(n.p,{children:["Has a NativeArray for positions, rotations, and scales. Runs ",(0,s.jsx)(n.code,{children:"UpdateMatrixJob"})," every frame to update the matrix data to match the data inside of the ",(0,s.jsx)(n.code,{children:"NativeArray"})," of positions, rotations and scale. Has public methods for setting the data, however, it is recommended that if you are updating many at once it is best to use a job."]}),"\n",(0,s.jsx)(n.h3,{id:"public-methods-2",children:"Public Methods"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public void SetData(int index, float3 position, quaternion rotation, float3 scale)\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public void SetPosition(int index, float3 position)\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public void SetRotation(int index, Quaternion rotation)\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public void SetScale(int index, float3 scale)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"multi-instance-manager",children:"Multi Instance Manager"}),"\n",(0,s.jsx)(n.p,{children:"Instance manager that allows multiple different meshes to be used. Not as performant as writing multiple managers, however, having the centeralized data makes it much easier to use."}),"\n",(0,s.jsxs)(n.p,{children:["When allocating, the ",(0,s.jsx)(n.code,{children:"NativeArray"})," for ",(0,s.jsx)(n.code,{children:"MatrixData"}),", it will be the size of ",(0,s.jsx)(n.code,{children:"instances * meshes"}),". When rendering, it gets subarrays from ",(0,s.jsx)(n.code,{children:"MatrixData"})," for grouping the different meshes."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"img alt",src:a(4685).A+"",width:"1300",height:"256"})}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["Above MatrixData, ",(0,s.jsx)(n.code,{children:"meshGroupLength"})," is referred to as ",(0,s.jsx)(n.code,{children:"matrixLength"})]})}),"\n",(0,s.jsxs)(n.p,{children:["There is a ",(0,s.jsx)(n.code,{children:"NativeArray"})," for position, rotation and scale which is represented as Data and on the individual mesh case, M1, M2, M3 and M4. There is also a ",(0,s.jsx)(n.code,{children:"NativeArray"})," of byte which is ",(0,s.jsx)(n.code,{children:"_meshGroup"}),", this represents which mesh this data belongs to. ",(0,s.jsx)(n.code,{children:"M1=_meshGroup[0]"}),", ",(0,s.jsx)(n.code,{children:"M2=_meshGroup[1]"}),", ",(0,s.jsx)(n.code,{children:"M3=_meshGroup[2]"}),", etc. Based on the diagram there are 3 different meshes to choose from, Cube, Capsule and Sphere. As such, there needs to be 12 elements to ",(0,s.jsx)(n.code,{children:"_matrixData"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"img alt",src:a(2918).A+"",width:"1300",height:"256"})}),"\n",(0,s.jsx)(n.p,{children:"This is what the rendering code looks like and how it gets the sub array."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"for (int i = 0; i < MeshesCount; i++)\r\n{\r\n    if (_matrixLength[i] == 0)\r\n        continue;\r\n\r\n    Graphics.RenderMeshInstanced(RenderParams[i],\r\n        Meshes[i].mesh,\r\n        Meshes[i].submeshIndex,\r\n        _matrixData.GetSubArray(i * AvailableInstances /*Start*/, _matrixLength[i]/*Length*/)\r\n        );\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This is the code that updates the matrix data."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"[BurstCompile]\r\nprotected struct UpdateMatrixJob : IJob\r\n{\r\n    public NativeArray<int> meshGroupsLength;\r\n    public NativeArray<Matrix4x4> matrixData;\r\n\r\n    [ReadOnly] public NativeArray<byte> meshGroup;\r\n\r\n    [ReadOnly] public NativeArray<float3> positions;\r\n    [ReadOnly] public NativeArray<Quaternion> rotations;\r\n    [ReadOnly] public NativeArray<float3> scales;\r\n\r\n    [BurstCompile]\r\n    public void Execute()\r\n    {\r\n        //Reset all lengths to 0\r\n        for (int i = 0; i < meshGroupsLength.Length; i++)\r\n            meshGroupsLength[i] = 0;\r\n\r\n        //Loop through all indexes\r\n        for (int i = 0; i < positions.Length; i++)\r\n        {\r\n            //Update position data. Multiply the total positions by meshGroup to get the correct offset, then use the meshGroupsLength to set the next element in the sequence.\r\n            matrixData[positions.Length * meshGroup[i] + meshGroupsLength[meshGroup[i]]] = Matrix4x4.TRS(positions[i], rotations[i], scales[i]);\r\n\r\n            //Increment the length of meshGroups\r\n            meshGroupsLength[meshGroup[i]]++;\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"lod-instance-manager",children:"LOD Instance Manager"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"LODInstance"})," manager inherits from ",(0,s.jsx)(n.code,{children:"DynamicInstanceManager"})," to manage switching the meshes. This simply changes the ",(0,s.jsx)(n.code,{children:"_meshGroup"})," based on distance camera. New inspector property for the render distance. An array of floats, must be the same length as meshes in manager."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},2918:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/Example2-153b6f67daf1cd340f5d6fb9e94df515.png"},3378:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/Flow-3609a5297f1c55e1b643e550c464d7ac.png"},4685:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/Example1-5b954399cac969879553f2a9dbca0046.png"},8453:(e,n,a)=>{a.d(n,{R:()=>r,x:()=>o});var s=a(6540);const i={},t=s.createContext(i);function r(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);